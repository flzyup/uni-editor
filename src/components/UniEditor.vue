<template>
  <div class="uni-editor">
    <!-- ÊñáÊ°£Ê†áÁ≠æÈ°µ -->
    <div class="document-tabs" v-if="openTabs.length > 0">
      <div class="tabs-container">
        <div class="tabs-main">
          <div class="tabs-scroll" ref="tabsScrollRef">
            <div
              v-for="tab in openTabs"
              :key="tab.id"
              class="tab"
              :class="{
                active: tab.id === activeTabId,
                modified: isDocumentModified(tab.id)
              }"
              @click="selectTab(tab.id)"
            >
              <div class="tab-content">
                <div class="tab-icon">üìù</div>
                <div class="tab-title" :title="getDocument(tab.id)?.title">
                  {{ getDocument(tab.id)?.title || t('documents.untitled') }}
                </div>
                <div
                  class="tab-close"
                  @click.stop="closeTab(tab.id)"
                  v-if="openTabs.length > 1"
                  :title="isDocumentModified(tab.id) ? t('documents.unsavedChangesTitle') : t('documents.closeTabTitle')"
                >
                  <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                    <path d="M9.5 3.5L8.5 2.5L6 5L3.5 2.5L2.5 3.5L5 6L2.5 8.5L3.5 9.5L6 7L8.5 9.5L9.5 8.5L7 6L9.5 3.5Z"/>
                  </svg>
                </div>
              </div>
            </div>
          </div>
          <div class="tabs-actions">
            <button class="action-btn" @click="toggleDocumentManager" :title="showDocumentManager ? t('documents.hideManager') : t('documents.showManager')">
              <svg v-if="showDocumentManager" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M1 6.5A1.5 1.5 0 0 1 2.5 5h3.38a1.5 1.5 0 0 1 1.06.44L8.38 7H13.5A1.5 1.5 0 0 1 15 8.354l-.8 5.32A1.5 1.5 0 0 1 12.72 15H3.28a1.5 1.5 0 0 1-1.48-1.326L1 6.5Z"/>
                <path d="M15 6.5H1V3.5A1.5 1.5 0 0 1 2.5 2h3.38a1.5 1.5 0 0 1 1.06.44L8.38 4H13.5A1.5 1.5 0 0 1 15 5.5v1Z"/>
              </svg>
              <svg v-else width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
                <path d="M1 3.5A1.5 1.5 0 0 1 2.5 2h11A1.5 1.5 0 0 1 15 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-11A1.5 1.5 0 0 1 1 12.5v-9zM2.5 3a.5.5 0 0 0-.5.5V5h12V3.5a.5.5 0 0 0-.5-.5h-11zM14 6H2v6.5a.5.5 0 0 0 .5.5h11a.5.5 0 0 0 .5-.5V6z"/>
              </svg>
            </button>
            <button class="action-btn" @click="createNewDocument" :title="t('documents.newDocument')">
              <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="tabs-scrollbar" v-show="showScrollbar">
          <div
            class="tabs-scrollbar-thumb"
            :style="{
              width: scrollbarThumbWidth + '%',
              transform: `translateX(${scrollbarThumbPosition}px)`
            }"
          ></div>
        </div>
      </div>
    </div>

    <!-- ÊñáÊ°£ÁÆ°ÁêÜÂô® -->
    <div class="document-manager" v-if="showDocumentManager">
      <div class="manager-header">
        <div class="header-title">
          <h3>{{ t('documents.manager') }}</h3>
          <span class="document-count">
            <template v-if="searchQuery.trim()">
              {{ t('documents.documentCount', { count: filteredDocumentsAll.length }) }}/{{ allDocuments.length }}
            </template>
            <template v-else>
              {{ t('documents.documentCount', { count: filteredDocuments.length }) }}
              <span v-if="showLoadMore">
                /{{ allDocuments.length }}
              </span>
            </template>
          </span>
        </div>
        <div class="header-search">
          <input
            v-model="searchQuery"
            type="text"
            class="search-input"
            :placeholder="$t('common.search') || 'ÊêúÁ¥¢ÊñáÊ°£...'"
            @input="handleSearch"
          >
          <svg v-if="!searchQuery" class="search-icon" width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
            <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
          </svg>
          <button v-else class="search-clear" @click="clearSearch" title="Ê∏ÖÈô§ÊêúÁ¥¢">
            <svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor">
              <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
            </svg>
          </button>
        </div>
      </div>
      <div class="manager-content">
        <div class="document-list">
          <div
            v-for="doc in filteredDocuments"
            :key="doc.id"
            class="document-item"
            :class="{
              active: doc.id === activeTabId,
              closed: !isTabOpen(doc.id),
              modified: isDocumentModified(doc.id),
              selected: selectedDocumentId === doc.id
            }"
            @click="selectDocument(doc.id)"
            @dblclick="openDocument(doc.id)"
          >
            <div class="document-info">
              <div class="document-title">
                <span class="doc-icon">üìù</span>
                <span class="title-text">{{ doc.title }}</span>
              </div>
              <div class="document-meta">
                <span class="doc-date">{{ formatDate(doc.updatedAt) }}</span>
                <span class="doc-size">{{ t('documents.charactersCount', { count: doc.content?.length || 0 }) }}</span>
              </div>
            </div>
            <div class="document-actions" @click.stop>
              <button
                class="doc-action-btn"
                @click.stop="handleDocumentTabAction(doc.id)"
                :title="getTabActionTitle(doc.id)"
              >
                <!-- Êú™ÊâìÂºÄÔºöÊòæÁ§∫ÊâìÂºÄÂõæÊ†á -->
                <svg v-if="!isTabOpen(doc.id)" width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                  <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                  <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
                </svg>
                <!-- Â∑≤ÊâìÂºÄ‰ΩÜÈùûÊ¥ªË∑ÉÔºöÊòæÁ§∫ÂÆö‰ΩçÂõæÊ†á -->
                <svg v-else-if="doc.id !== activeTabId" width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                  <path d="M8 4a4 4 0 1 1 0 8 4 4 0 0 1 0-8z"/>
                </svg>
                <!-- ÂΩìÂâçÊ¥ªË∑ÉÔºöÊòæÁ§∫ÂÖ≥Èó≠ÂõæÊ†áÔºà‰∏éÊ†áÁ≠æÊ†èX‰∏ÄËá¥Ôºâ -->
                <svg v-else width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                  <path d="M9.5 3.5L8.5 2.5L6 5L3.5 2.5L2.5 3.5L5 6L2.5 8.5L3.5 9.5L6 7L8.5 9.5L9.5 8.5L7 6L9.5 3.5Z"/>
                </svg>
              </button>
              <button
                class="doc-action-btn"
                @click.stop="importMarkdownToDocument(doc.id)"
                :title="t('documents.importMD')"
              >
                <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                  <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                  <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/>
                </svg>
              </button>
              <button
                class="doc-action-btn"
                @click.stop="exportMarkdownFromDocument(doc.id)"
                :title="t('documents.exportMD')"
              >
                <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                  <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                  <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                </svg>
              </button>
              <button
                class="doc-action-btn"
                @click.stop="duplicateDocument(doc.id)"
                :title="t('documents.duplicateDocument')"
              >
                <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                  <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
                  <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
                </svg>
              </button>
              <button
                class="doc-action-btn danger"
                @click.stop="confirmDeleteDocument(doc.id)"
                :title="t('documents.deleteDocument')"
                :disabled="allDocuments.length <= 1"
              >
                <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                  <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                  <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                </svg>
              </button>
            </div>
          </div>
        </div>

        <!-- Âä†ËΩΩÊõ¥Â§öÊåâÈíÆ -->
        <div v-if="showLoadMore" class="load-more-container">
          <button class="load-more-btn" @click="loadMoreDocuments">
            <span>{{ $t('common.loadMore') || 'Âä†ËΩΩÊõ¥Â§ö' }}</span>
            <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
              <path d="M7.646 9.646a.5.5 0 0 1 .708 0L12 13.293V2.5a.5.5 0 0 1 1 0v10.793l3.646-3.647a.5.5 0 0 1 .708.708l-4.5 4.5a.5.5 0 0 1-.708 0l-4.5-4.5a.5.5 0 0 1 0-.708z"/>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- ÁºñËæëÂô® -->
    <div class="editor-container">
      <div ref="elRef" class="vditor-host"></div>
    </div>

    <!-- Âà†Èô§Á°ÆËÆ§ÂØπËØùÊ°Ü -->
    <div v-if="showDeleteConfirm" class="modal-overlay" @click="cancelDelete">
      <div class="modal-dialog" @click.stop>
        <div class="modal-header">
          <h3>{{ t('documents.confirmDelete') }}</h3>
        </div>
        <div class="modal-body">
          <p>{{ t('documents.confirmDeleteMessage', { title: getDocument(documentToDelete)?.title }) }}</p>
          <p class="warning-text">{{ t('documents.warningNotRecoverable') }}</p>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" @click="cancelDelete">{{ t('common.cancel') }}</button>
          <button class="btn btn-danger" @click="deleteDocument">{{ t('common.confirm') }}</button>
        </div>
      </div>
    </div>

    <!-- ÂØºÂÖ•Ë¶ÜÁõñÁ°ÆËÆ§ÂØπËØùÊ°Ü -->
    <div v-if="showImportConfirm" class="modal-overlay" @click="cancelImport">
      <div class="modal-dialog" @click.stop>
        <div class="modal-header">
          <h3>{{ t('documents.confirmImport') }}</h3>
        </div>
        <div class="modal-body">
          <p>{{ t('documents.confirmImportMessage', { title: getDocument(importTargetDocId)?.title }) }}</p>
          <p>{{ t('documents.confirmImportSubMessage') }}</p>
          <p class="warning-text">{{ t('documents.warningNotRecoverable') }}</p>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" @click="cancelImport">{{ t('common.cancel') }}</button>
          <button class="btn btn-primary" @click="confirmImport">{{ t('documents.confirmImportAction') }}</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted, onBeforeUnmount, nextTick } from 'vue'
import { useI18n } from 'vue-i18n'
import Vditor from 'vditor'
import 'vditor/dist/index.css'
import zhMessages from '../locales/zh.js'
import enMessages from '../locales/en.js'
import {
  saveImage,
  convertContentForEditor,
  convertContentForStorage,
  clearImageCache,
  extractImageIdsFromContent,
  cleanupUnusedImages,
  hasIndexedDBSupport
} from '../utils/imageStore.js'

const props = defineProps({
  pageTheme: { type: String, default: 'theme-dark' }
})
const emit = defineEmits(['update:html', 'editorScroll'])

const { locale, t } = useI18n()

const elRef = ref(null)
let vd = null
let isVditorReady = false
const scrollCleanups = []

// ÊñáÊ°£ÁÆ°ÁêÜÁä∂ÊÄÅ
const allDocuments = ref([]) // ÊâÄÊúâÊñáÊ°£ÁºìÂ≠ò
const openTabs = ref([]) // ÂΩìÂâçÊâìÂºÄÁöÑÊ†áÁ≠æÈ°µ
const activeTabId = ref('') // ÂΩìÂâçÊ¥ªË∑ÉÁöÑÊ†áÁ≠æ
const selectedDocumentId = ref('') // Âú®ÊñáÊ°£ÁÆ°ÁêÜÂô®‰∏≠ÈÄâ‰∏≠ÁöÑÊñáÊ°£
const showDocumentManager = ref(false) // ÊòØÂê¶ÊòæÁ§∫ÊñáÊ°£ÁÆ°ÁêÜÂô®
const showDeleteConfirm = ref(false) // Âà†Èô§Á°ÆËÆ§ÂØπËØùÊ°Ü
const documentToDelete = ref('') // ÂæÖÂà†Èô§ÁöÑÊñáÊ°£ID
const showImportConfirm = ref(false) // ÂØºÂÖ•Á°ÆËÆ§ÂØπËØùÊ°Ü
const importTargetDocId = ref('') // ÂØºÂÖ•ÁõÆÊ†áÊñáÊ°£ID
const pendingImportFile = ref(null) // ÂæÖÂØºÂÖ•ÁöÑÊñá‰ª∂

// ÊêúÁ¥¢Áõ∏ÂÖ≥Áä∂ÊÄÅ
const searchQuery = ref('') // ÊêúÁ¥¢ÂÖ≥ÈîÆËØç
const searchDebounceTimer = ref(null) // Èò≤ÊäñÂÆöÊó∂Âô®

// ÂàÜÈ°µÁõ∏ÂÖ≥Áä∂ÊÄÅ
const currentPage = ref(1) // ÂΩìÂâçÈ°µÁ†Å
const pageSize = ref(20) // ÊØèÈ°µÊòæÁ§∫Êï∞Èáè
const showLoadMore = ref(false) // ÊòØÂê¶ÊòæÁ§∫Âä†ËΩΩÊõ¥Â§öÊåâÈíÆ

// ÊñáÊ°£‰øÆÊîπÁä∂ÊÄÅË∑üË∏™
const documentModifications = ref(new Map())

// ÊªöÂä®Êù°Áõ∏ÂÖ≥
const tabsScrollRef = ref(null)
const showScrollbar = ref(false)
const scrollbarThumbWidth = ref(100)
const scrollbarThumbPosition = ref(0)

// ËÆ°ÁÆóÂ±ûÊÄßÔºöÊåâ‰øÆÊîπÊó∂Èó¥ÂÄíÂ∫èÊéíÂàóÁöÑÊñáÊ°£ÂàóË°®
const sortedDocuments = computed(() => {
  return [...allDocuments.value].sort((a, b) => b.updatedAt - a.updatedAt)
})

// ËÆ°ÁÆóÂ±ûÊÄßÔºöÁ≠õÈÄâÂêéÁöÑÊñáÊ°£ÂàóË°®ÔºàÂÆåÊï¥Ôºâ
const filteredDocumentsAll = computed(() => {
  if (!searchQuery.value.trim()) {
    return sortedDocuments.value
  }

  const query = searchQuery.value.toLowerCase().trim()
  return sortedDocuments.value.filter(doc => {
    return doc.title.toLowerCase().includes(query) ||
           (doc.content && doc.content.toLowerCase().includes(query))
  })
})

// ËÆ°ÁÆóÂ±ûÊÄßÔºöÂΩìÂâçÈ°µÊòæÁ§∫ÁöÑÊñáÊ°£ÂàóË°®
const filteredDocuments = computed(() => {
  const allDocs = filteredDocumentsAll.value
  const maxItems = currentPage.value * pageSize.value

  // Êõ¥Êñ∞ÊòØÂê¶ÊòæÁ§∫Âä†ËΩΩÊõ¥Â§öÊåâÈíÆ
  showLoadMore.value = allDocs.length > maxItems

  return allDocs.slice(0, maxItems)
})

// ÂàùÂßãÂåñÊñáÊ°£ÁÆ°ÁêÜ
function initializeDocuments() {
  try {
    // Âä†ËΩΩÊâÄÊúâÊñáÊ°£
    const savedDocs = localStorage.getItem('uni.allDocuments')
    if (savedDocs) {
      const parsed = JSON.parse(savedDocs)
      if (Array.isArray(parsed) && parsed.length > 0) {
        allDocuments.value = parsed
      }
    }

    // Âä†ËΩΩÊâìÂºÄÁöÑÊ†áÁ≠æÈ°µ
    const savedTabs = localStorage.getItem('uni.openTabs')
    if (savedTabs && allDocuments.value.length > 0) {
      const parsed = JSON.parse(savedTabs)
      if (Array.isArray(parsed) && parsed.length > 0) {
        // ËøáÊª§Êéâ‰∏çÂ≠òÂú®ÁöÑÊñáÊ°£Ê†áÁ≠æ
        const validTabs = parsed.filter(tab =>
          allDocuments.value.find(doc => doc.id === tab.id)
        )

        if (validTabs.length > 0) {
          openTabs.value = validTabs
          const activeId = localStorage.getItem('uni.activeTabId')
          if (activeId && validTabs.find(tab => tab.id === activeId)) {
            activeTabId.value = activeId
          } else {
            activeTabId.value = validTabs[0].id
          }
          return
        }
      }
    }
  } catch (e) {
    console.warn('Failed to load documents from localStorage:', e)
  }

  // Â¶ÇÊûúÊ≤°ÊúâÊúâÊïàÊï∞ÊçÆÔºåÂàõÂª∫ÈªòËÆ§ÊñáÊ°£
  if (allDocuments.value.length === 0) {
    createDefaultDocument()
  } else {
    // Â¶ÇÊûúÊúâÊñáÊ°£‰ΩÜÊ≤°ÊúâÊâìÂºÄÁöÑÊ†áÁ≠æÔºåÊâìÂºÄÁ¨¨‰∏Ä‰∏™ÊñáÊ°£
    openTabs.value = [{ id: allDocuments.value[0].id }]
    activeTabId.value = allDocuments.value[0].id
  }
}

function createDefaultDocument() {
  const defaultDoc = {
    id: generateId(),
    title: t('editor.welcome'),
    content: getDefaultContent(),
    mode: 'wysiwyg',
    createdAt: Date.now(),
    updatedAt: Date.now()
  }

  allDocuments.value = [defaultDoc]
  openTabs.value = [{ id: defaultDoc.id }]
  activeTabId.value = defaultDoc.id
  saveToLocalStorage()
}

function generateId() {
  return 'doc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
}

function getDefaultContent() {
  const currentLocale = locale.value
  const messages = {
    'zh': zhMessages.defaultTemplate,
    'en': enMessages.defaultTemplate
  }
  return messages[currentLocale] || messages['zh']
}

function saveToLocalStorage() {
  try {
    localStorage.setItem('uni.allDocuments', JSON.stringify(allDocuments.value))
    localStorage.setItem('uni.openTabs', JSON.stringify(openTabs.value))
    localStorage.setItem('uni.activeTabId', activeTabId.value)
  } catch (e) {
    console.warn('Failed to save documents to localStorage:', e)
  }

  scheduleImageCleanup()
}

let imageCleanupTimer = null

function scheduleImageCleanup() {
  if (typeof window === 'undefined' || !hasIndexedDBSupport()) return
  if (imageCleanupTimer) {
    clearTimeout(imageCleanupTimer)
  }

  imageCleanupTimer = window.setTimeout(async () => {
    imageCleanupTimer = null
    await performImageCleanup()
  }, 800)
}

async function performImageCleanup() {
  try {
    const usedIds = new Set()
    allDocuments.value.forEach(doc => {
      if (!doc?.content) return
      const normalized = convertContentForStorage(doc.content)
      const ids = extractImageIdsFromContent(normalized)
      ids.forEach(id => usedIds.add(id))
    })

    // Include current editor content if it differs from stored value
    if (vd && isVditorReady) {
      const editorContent = convertContentForStorage(vd.getValue())
      const ids = extractImageIdsFromContent(editorContent)
      ids.forEach(id => usedIds.add(id))
    }

    await cleanupUnusedImages(usedIds)
  } catch (error) {
    console.warn('Image cleanup failed:', error)
  }
}

function getDocument(docId) {
  return allDocuments.value.find(d => d.id === docId)
}

function getActiveDocument() {
  return getDocument(activeTabId.value)
}

function isTabOpen(docId) {
  return openTabs.value.some(tab => tab.id === docId)
}

function isDocumentModified(docId) {
  return documentModifications.value.has(docId)
}

function markDocumentModified(docId) {
  documentModifications.value.set(docId, true)
}

function markDocumentSaved(docId) {
  documentModifications.value.delete(docId)
}

async function createNewDocument() {
  const newDoc = {
    id: generateId(),
    title: `${t('documents.untitled')} ${allDocuments.value.length + 1}`,
    content: '',
    mode: 'wysiwyg',
    createdAt: Date.now(),
    updatedAt: Date.now()
  }

  allDocuments.value.push(newDoc)
  await openDocument(newDoc.id)
  saveToLocalStorage()
  // Êõ¥Êñ∞ÊªöÂä®Êù°
  nextTick(() => updateScrollbar())
}

async function openDocument(docId) {
  // Â¶ÇÊûúÊ†áÁ≠æÈ°µÊú™ÊâìÂºÄÔºåÂàôÊâìÂºÄÂÆÉ
  if (!isTabOpen(docId)) {
    openTabs.value.push({ id: docId })
  }

  await selectTab(docId)
  saveToLocalStorage()
  // Êõ¥Êñ∞ÊªöÂä®Êù°
  nextTick(() => updateScrollbar())
}

async function selectTab(docId) {
  if (docId === activeTabId.value) return

  // ‰øùÂ≠òÂΩìÂâçÊñáÊ°£Áä∂ÊÄÅ
  saveCurrentDocumentState()

  // ÂàáÊç¢Âà∞Êñ∞ÊñáÊ°£
  activeTabId.value = docId
  const newDoc = getActiveDocument()

  if (newDoc && vd && isVditorReady) {
    const displayContent = await convertContentForEditor(newDoc.content || '')
    // Êõ¥Êñ∞ÁºñËæëÂô®ÂÜÖÂÆπ
    vd.setValue(displayContent, false)

    // Â¶ÇÊûúÊñáÊ°£ÊúâÂÜÖÂÆπ‰ΩÜÊ†áÈ¢òÊòØÈªòËÆ§ÁöÑÔºåÂ∞ùËØïÊèêÂèñÊ†áÈ¢ò
    if (newDoc.content && newDoc.title.startsWith(t('documents.untitled'))) {
      updateDocumentTitle(newDoc.id, newDoc.content)
    }

    // ÂèëÈÄÅHTMLÊõ¥Êñ∞
    emit('update:html', vd.getHTML())
  }

  saveToLocalStorage()
}

async function closeTab(docId) {
  if (openTabs.value.length <= 1) return

  const index = openTabs.value.findIndex(tab => tab.id === docId)
  if (index === -1) return

  // Â¶ÇÊûúÊúâÊú™‰øùÂ≠òÁöÑÊõ¥ÊîπÔºåÊèêÁ§∫Áî®Êà∑
  if (isDocumentModified(docId)) {
    if (!confirm(t('documents.unsavedChanges') + 'Ôºå' + t('documents.confirmClose'))) {
      return
    }
  }

  openTabs.value.splice(index, 1)

  // Â¶ÇÊûúÂÖ≥Èó≠ÁöÑÊòØÂΩìÂâçÊ¥ªË∑ÉÊ†áÁ≠æÔºåÂàáÊç¢Âà∞ÂÖ∂‰ªñÊ†áÁ≠æ
  if (docId === activeTabId.value) {
    const newIndex = Math.min(index, openTabs.value.length - 1)
    await selectTab(openTabs.value[newIndex].id)
  }

  saveToLocalStorage()
  // Êõ¥Êñ∞ÊªöÂä®Êù°
  nextTick(() => updateScrollbar())
}

async function duplicateDocument(docId) {
  const originalDoc = getDocument(docId)
  if (!originalDoc) return

  const newDoc = {
    id: generateId(),
    title: originalDoc.title + ' - ' + t('documents.copy'),
    content: originalDoc.content,
    mode: originalDoc.mode,
    createdAt: Date.now(),
    updatedAt: Date.now()
  }

  allDocuments.value.push(newDoc)
  await openDocument(newDoc.id)
  saveToLocalStorage()
}

function confirmDeleteDocument(docId) {
  if (allDocuments.value.length <= 1) return

  documentToDelete.value = docId
  showDeleteConfirm.value = true
}

function deleteDocument() {
  const docId = documentToDelete.value

  // ‰ªéÊâÄÊúâÊñáÊ°£‰∏≠Âà†Èô§
  const docIndex = allDocuments.value.findIndex(d => d.id === docId)
  if (docIndex !== -1) {
    allDocuments.value.splice(docIndex, 1)
  }

  // ‰ªéÊâìÂºÄÁöÑÊ†áÁ≠æ‰∏≠Âà†Èô§
  const tabIndex = openTabs.value.findIndex(tab => tab.id === docId)
  if (tabIndex !== -1) {
    openTabs.value.splice(tabIndex, 1)
  }

  // Ê∏ÖÈô§‰øÆÊîπÁä∂ÊÄÅ
  documentModifications.value.delete(docId)

  // Â¶ÇÊûúÂà†Èô§ÁöÑÊòØÂΩìÂâçÊ¥ªË∑ÉÊñáÊ°£ÔºåÂàáÊç¢Âà∞ÂÖ∂‰ªñÊñáÊ°£
  if (docId === activeTabId.value && openTabs.value.length > 0) {
    const newIndex = Math.min(tabIndex, openTabs.value.length - 1)
    selectTab(openTabs.value[newIndex].id)
  } else if (openTabs.value.length === 0 && allDocuments.value.length > 0) {
    // Â¶ÇÊûúÊ≤°ÊúâÊâìÂºÄÁöÑÊ†áÁ≠æ‰ΩÜËøòÊúâÊñáÊ°£ÔºåÊâìÂºÄÁ¨¨‰∏Ä‰∏™ÊñáÊ°£
    openDocument(allDocuments.value[0].id)
  }

  showDeleteConfirm.value = false
  documentToDelete.value = ''
  saveToLocalStorage()
}

function cancelDelete() {
  showDeleteConfirm.value = false
  documentToDelete.value = ''
}

function toggleDocumentManager() {
  showDocumentManager.value = !showDocumentManager.value
}

function saveCurrentDocumentState(preparedContent) {
  const activeDoc = getActiveDocument()
  if (activeDoc && vd && isVditorReady) {
    const currentEditorValue = vd.getValue()
    const currentContent = typeof preparedContent === 'string'
      ? preparedContent
      : convertContentForStorage(currentEditorValue)
    const currentMode = vd.getCurrentMode()

    if (activeDoc.content !== currentContent) {
      activeDoc.content = currentContent
      activeDoc.updatedAt = Date.now()
      markDocumentModified(activeDoc.id)

      // Êõ¥Êñ∞ÊñáÊ°£Ê†áÈ¢ò
      updateDocumentTitle(activeDoc.id, currentContent)
    }

    if (activeDoc.mode !== currentMode) {
      activeDoc.mode = currentMode
    }
  }
}

function formatDate(timestamp) {
  const date = new Date(timestamp)
  const now = new Date()
  const diff = now.getTime() - date.getTime()

  if (diff < 60000) return t('documents.timeJustNow')
  if (diff < 3600000) return t('documents.timeMinutesAgo', { minutes: Math.floor(diff / 60000) })
  if (diff < 86400000) return t('documents.timeHoursAgo', { hours: Math.floor(diff / 3600000) })
  if (diff < 604800000) return t('documents.timeDaysAgo', { days: Math.floor(diff / 86400000) })

  return date.toLocaleDateString()
}

function getEditorTheme(v) {
  return v === 'theme-dark' ? 'dark' : 'classic'
}

function getVditorLang(locale) {
  const langMap = {
    'zh': 'zh_CN',
    'en': 'en_US'
  }
  return langMap[locale] || 'en_US'
}

// ÂàùÂßãÂåñÁºñËæëÂô®
async function initVditor() {
  if (!elRef.value) return

  const activeDoc = getActiveDocument()
  const initialContent = activeDoc?.content || getDefaultContent()
  const initialMode = activeDoc?.mode || 'wysiwyg'
  const editorReadyContent = await convertContentForEditor(initialContent || '')

  vd = new Vditor(elRef.value, {
    value: editorReadyContent,
    cache: { enable: false },
    height: '100%',
    mode: initialMode,
    lang: getVditorLang(locale.value),
    theme: getEditorTheme(props.pageTheme),
    toolbarConfig: { pin: true },
    toolbar: [
      'headings', 'bold', 'italic', 'strike', '|',
      'list', 'ordered-list', 'check', 'outdent', 'indent', 'outline', '|',
      'quote', 'line', 'code', 'inline-code', 'insert-before', 'insert-after', '|',
      'table', 'link', 'upload', 'emoji', '|',
      'undo', 'redo', '|',
      'edit-mode',
    ],
    counter: { enable: true },
    upload: {
      accept: 'image/*',
      multiple: true,
      handler: handleImageUpload
    },
    preview: {
      theme: {
        current: getEditorTheme(props.pageTheme),
        path: 'https://unpkg.com/vditor/dist/css/content-theme'
      },
      hljs: {
        style: getEditorTheme(props.pageTheme) === 'dark' ? 'github-dark' : 'github'
      }
    },
    hint: { delay: 500 },
    typewriterMode: false,
    after: () => {
      isVditorReady = true
      console.log('Vditor ready')

      // ÁªëÂÆöÊªöÂä®‰∫ã‰ª∂
      bindScrollEvents()

      // ÂàùÂßãÂåñÊó∂ÂèëÈÄÅÂÜÖÂÆπ
      if (vd) {
        emit('update:html', vd.getHTML())
      }
    },
    input: (value) => {
      if (isVditorReady) {
        const storageContent = convertContentForStorage(value)

        // Ê†áËÆ∞ÂΩìÂâçÊñáÊ°£‰∏∫Â∑≤‰øÆÊîπ
        const activeDoc = getActiveDocument()
        if (activeDoc && activeDoc.content !== storageContent) {
          markDocumentModified(activeDoc.id)
          activeDoc.updatedAt = Date.now()

          // Êõ¥Êñ∞ÊñáÊ°£Ê†áÈ¢ò
          updateDocumentTitle(activeDoc.id, storageContent)
        }

        emit('update:html', vd.getHTML())
      }
    },
    select: () => {
      if (isVditorReady) {
        emit('update:html', vd.getHTML())
      }
    },
    blur: () => {
      if (isVditorReady) {
        const storageContent = convertContentForStorage(vd.getValue())
        // ‰øùÂ≠òÂΩìÂâçÊñáÊ°£Áä∂ÊÄÅ
        saveCurrentDocumentState(storageContent)

        // Ê†áËÆ∞ÊñáÊ°£‰∏∫Â∑≤‰øùÂ≠ò
        const activeDoc = getActiveDocument()
        if (activeDoc) {
          markDocumentSaved(activeDoc.id)
          // ÊúÄÁªàÁ°ÆËÆ§Ê†áÈ¢òÊõ¥Êñ∞
          updateDocumentTitle(activeDoc.id, storageContent)
        }

        saveToLocalStorage()
        emit('update:html', vd.getHTML())
      }
    }
  })
}

async function handleImageUpload(files) {
  if (!files) return
  const fileList = Array.from(files).filter(file => file instanceof File)
  if (fileList.length === 0) return

  const fragments = []

  for (const file of fileList) {
    try {
      const { url, name } = await saveImage(file)
      if (!url) continue

      const rawName = name || file.name || 'image'
      const alt = rawName.replace(/\.[^/.]+$/, '') || 'image'
      fragments.push(`![${alt}](${url})`)
    } catch (error) {
      console.warn('Image upload failed:', error)
    }
  }

  if (fragments.length > 0 && vd) {
    const markdown = fragments.join('\n\n') + '\n'
    vd.insertValue(markdown)
    emit('update:html', vd.getHTML())
  }
}

// ÁªëÂÆöÊªöÂä®‰∫ã‰ª∂
function bindScrollEvents() {
  if (!vd || !vd.vditor?.element) return

  // Ê∏ÖÁêÜ‰πãÂâçÁöÑ‰∫ã‰ª∂ÁõëÂê¨
  scrollCleanups.forEach(cleanup => cleanup())
  scrollCleanups.length = 0

  // Êü•ÊâæÊâÄÊúâÂèØËÉΩÁöÑÊªöÂä®ÂÆπÂô®
  const scrollContainers = [
    vd.vditor.element.querySelector('.vditor-content'),
    vd.vditor.element.querySelector('.vditor-ir'),
    vd.vditor.element.querySelector('.vditor-wysiwyg'),
    vd.vditor.element.querySelector('.vditor-sv'),
    vd.vditor.element.querySelector('.vditor-preview'),
  ].filter(Boolean)

  scrollContainers.forEach(container => {
    if (container) {
      const scrollHandler = () => {
        const scrollTop = container.scrollTop
        const scrollHeight = container.scrollHeight
        const clientHeight = container.clientHeight
        const scrollRatio = scrollHeight > clientHeight ? scrollTop / (scrollHeight - clientHeight) : 0
        emit('editorScroll', { scrollRatio, scrollTop })
      }

      container.addEventListener('scroll', scrollHandler, { passive: true })
      scrollCleanups.push(() => {
        container.removeEventListener('scroll', scrollHandler)
      })
    }
  })
}

// ÊêúÁ¥¢Áõ∏ÂÖ≥ÂáΩÊï∞
function handleSearch() {
  // ÊêúÁ¥¢Êó†ÈúÄÈò≤ÊäñÔºåÂõ†‰∏∫computed‰ºöËá™Âä®Â§ÑÁêÜ
  // filteredDocumentsËÆ°ÁÆóÂ±ûÊÄß‰ºöÁ´ãÂç≥ÂèçÊò†ÊêúÁ¥¢ÁªìÊûú
}

function clearSearch() {
  searchQuery.value = ''
  // ÈáçÁΩÆÂàÜÈ°µ
  currentPage.value = 1
}

function loadMoreDocuments() {
  currentPage.value += 1
}

// ÁõëÂê¨ÊêúÁ¥¢Êü•ËØ¢ÂèòÂåñÔºåÈáçÁΩÆÂàÜÈ°µ
watch(searchQuery, () => {
  currentPage.value = 1
})

// ÁõëÂê¨‰∏ªÈ¢òÂèòÂåñ
watch(() => props.pageTheme, (newTheme) => {
  if (vd && isVditorReady) {
    vd.setTheme(
      getEditorTheme(newTheme),
      getEditorTheme(newTheme),
      getEditorTheme(newTheme) === 'dark' ? 'github-dark' : 'github'
    )
  }
})

// ÁõëÂê¨ËØ≠Ë®ÄÂèòÂåñ
watch(locale, async (newLocale) => {
  if (vd && isVditorReady) {
    // ‰øùÂ≠òÂΩìÂâçÂÜÖÂÆπ
    saveCurrentDocumentState()
    const activeDoc = getActiveDocument()
    const storedContent = activeDoc?.content || ''

    // ÈîÄÊØÅÂΩìÂâçÂÆû‰æã
    try {
      scrollCleanups.forEach(cleanup => cleanup())
      scrollCleanups.length = 0
      vd.destroy()
    } catch (error) {
      console.warn('Failed to destroy Vditor:', error)
    }

    // ÈáçÊñ∞ÂàùÂßãÂåñ
    await nextTick()
    await initVditor()

    if (vd && isVditorReady) {
      const displayContent = await convertContentForEditor(storedContent)
      vd.setValue(displayContent, false)
      emit('update:html', vd.getHTML())
    }
  }
})

// ÈîÄÊØÅÁºñËæëÂô®
function destroyVditor() {
  if (vd) {
    try {
      scrollCleanups.forEach(cleanup => cleanup())
      scrollCleanups.length = 0
      vd.destroy()
    } catch (error) {
      console.warn('Error destroying Vditor:', error)
    }
    clearImageCache()
    vd = null
    isVditorReady = false
  }
}

// ÂØºÂá∫ÂäüËÉΩ
async function exportMarkdown() {
  const activeDoc = getActiveDocument()
  if (!activeDoc || !activeDoc.content) {
    throw new Error('No content to export')
  }

  const blob = new Blob([activeDoc.content], { type: 'text/markdown' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `${activeDoc.title || 'document'}.md`
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

// ÂØºÂÖ•ÂäüËÉΩ
async function importMarkdown() {
  return new Promise((resolve, reject) => {
    const input = document.createElement('input')
    input.type = 'file'
    input.accept = '.md,.markdown,.txt'

    input.onchange = async (e) => {
      const file = e.target.files[0]
      if (!file) {
        reject('No file selected')
        return
      }

      if (!file.name.match(/\.(md|markdown|txt)$/i)) {
        reject('Invalid file type')
        return
      }

      try {
        const content = await file.text()
        const fileName = file.name.replace(/\.(md|markdown|txt)$/i, '')

        // ÂàõÂª∫Êñ∞ÊñáÊ°£
        const newDoc = {
          id: generateId(),
          title: fileName,
          content: content,
          mode: 'wysiwyg',
          createdAt: Date.now(),
          updatedAt: Date.now()
        }

        allDocuments.value.push(newDoc)
        openDocument(newDoc.id)
        saveToLocalStorage()

        resolve()
      } catch (error) {
        reject(error)
      }
    }

    input.oncancel = () => {
      reject('Import cancelled')
    }

    input.click()
  })
}

// ÈíàÂØπÁâπÂÆöÊñáÊ°£ÁöÑÂØºÂá∫ÂäüËÉΩ
async function exportMarkdownFromDocument(docId) {
  try {
    const doc = getDocument(docId)
    if (!doc) {
      console.error('Document not found:', docId)
      return
    }

    const blob = new Blob([doc.content], { type: 'text/markdown' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `${doc.title || 'Êó†Ê†áÈ¢òÊñáÊ°£'}.md`
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)

    console.log('Markdown exported successfully')
  } catch (error) {
    console.error('Export failed:', error)
  }
}

// ÈíàÂØπÁâπÂÆöÊñáÊ°£ÁöÑÂØºÂÖ•ÂäüËÉΩ
async function importMarkdownToDocument(docId) {
  const input = document.createElement('input')
  input.type = 'file'
  input.accept = '.md,.markdown,.txt'

  input.onchange = async (e) => {
    const file = e.target.files[0]
    if (!file) return

    try {
      const doc = getDocument(docId)
      if (!doc) {
        console.error('Document not found:', docId)
        return
      }

      // Ê£ÄÊü•ÊñáÊ°£ÊòØÂê¶ÊúâÂÜÖÂÆπÔºåÂ¶ÇÊûúÊúâÂàôÊòæÁ§∫Á°ÆËÆ§ÂØπËØùÊ°Ü
      if (doc.content && doc.content.trim().length > 0) {
        importTargetDocId.value = docId
        pendingImportFile.value = file
        showImportConfirm.value = true
        return
      }

      // Â¶ÇÊûúÊñáÊ°£‰∏∫Á©∫ÔºåÁõ¥Êé•ÂØºÂÖ•
      await performImport(docId, file)
    } catch (error) {
      console.error('Import failed:', error)
    }
  }

  input.click()
}

// ÊâßË°åÂÆûÈôÖÁöÑÂØºÂÖ•Êìç‰Ωú
async function performImport(docId, file) {
  try {
    const rawContent = await file.text()
    const content = convertContentForStorage(rawContent)
    const fileName = file.name.replace(/\.(md|markdown|txt)$/i, '')

    const doc = getDocument(docId)
    if (!doc) {
      console.error('Document not found:', docId)
      return
    }

    // Êõ¥Êñ∞ÊñáÊ°£ÂÜÖÂÆπ
    doc.content = content
    doc.title = fileName || doc.title
    doc.updatedAt = Date.now()

    // Â¶ÇÊûúÊòØÂΩìÂâçÊ¥ªË∑ÉÊñáÊ°£ÔºåÊõ¥Êñ∞ÁºñËæëÂô®ÂÜÖÂÆπ
    if (docId === activeTabId.value && vd && isVditorReady) {
      const displayContent = await convertContentForEditor(content)
      vd.setValue(displayContent)
      emit('update:html', vd.getHTML())
    }

    // Ê†áËÆ∞ÊñáÊ°£Â∑≤‰øÆÊîπ
    markDocumentModified(docId)
    saveToLocalStorage()

    console.log('Markdown imported successfully')
  } catch (error) {
    console.error('Import failed:', error)
  }
}

// Á°ÆËÆ§ÂØºÂÖ•
function confirmImport() {
  if (importTargetDocId.value && pendingImportFile.value) {
    performImport(importTargetDocId.value, pendingImportFile.value)
  }
  cancelImport()
}

// ÂèñÊ∂àÂØºÂÖ•
function cancelImport() {
  showImportConfirm.value = false
  importTargetDocId.value = ''
  pendingImportFile.value = null
}

// Â§ÑÁêÜÊñáÊ°£Ê†áÁ≠æÈ°µÊìç‰Ωú
function handleDocumentTabAction(docId) {
  if (!isTabOpen(docId)) {
    // ÊñáÊ°£Êú™ÊâìÂºÄÔºåÊâìÂºÄÊ†áÁ≠æÈ°µ
    openDocument(docId)
  } else if (docId !== activeTabId.value) {
    // ÊñáÊ°£Â∑≤ÊâìÂºÄ‰ΩÜÈùûÊ¥ªË∑ÉÔºåÂàáÊç¢Âà∞ËØ•Ê†áÁ≠æ
    selectTab(docId)
  } else {
    // ÂΩìÂâçÊ¥ªË∑ÉÊñáÊ°£ÔºåÂÖ≥Èó≠Ê†áÁ≠æÈ°µÔºà‰ΩÜ‰∏çÂà†Èô§ÊñáÊ°£Ôºâ
    closeTab(docId)
  }
}

// Ëé∑ÂèñÊ†áÁ≠æÈ°µÊìç‰ΩúÁöÑÊèêÁ§∫ÊñáÊú¨
function getTabActionTitle(docId) {
  if (!isTabOpen(docId)) {
    return t('documents.openDocument')
  } else if (docId !== activeTabId.value) {
    return t('documents.locateTab')
  } else {
    return t('documents.closeTabTitle')
  }
}


// ÊèêÂèñÊñáÊ°£Ê†áÈ¢ò
function extractTitleFromContent(content) {
  if (!content) return null

  // Â∞ùËØïÂåπÈÖç markdown Ê†áÈ¢ò
  const headingMatch = content.match(/^#+\s*(.+)$/m)
  if (headingMatch) {
    return headingMatch[1].trim()
  }

  // Â∞ùËØïÂåπÈÖçÁ¨¨‰∏ÄË°åÈùûÁ©∫ÂÜÖÂÆπ
  const lines = content.split('\n')
  for (const line of lines) {
    const trimmed = line.trim()
    if (trimmed && !trimmed.startsWith('#')) {
      // ÁßªÈô§markdownÊ†ºÂºèÂπ∂ÈôêÂà∂ÈïøÂ∫¶
      const cleaned = trimmed.replace(/[*_`~\[\]]/g, '').trim()
      if (cleaned) {
        return cleaned.length > 50 ? cleaned.substring(0, 50) + '...' : cleaned
      }
    }
  }

  return null
}

// Êõ¥Êñ∞ÊñáÊ°£Ê†áÈ¢ò
function updateDocumentTitle(docId, content) {
  const doc = getDocument(docId)
  if (!doc) return

  const extractedTitle = extractTitleFromContent(content)

  if (extractedTitle) {
    // ÊÉÖÂÜµ1ÔºöÊñáÊ°£Ê†áÈ¢òÊòØÈªòËÆ§ÁöÑ"Êó†Ê†áÈ¢òÊñáÊ°£"Ê†ºÂºèÔºåÁõ¥Êé•Êõ¥Êñ∞
    if (doc.title.startsWith(t('documents.untitled'))) {
      doc.title = extractedTitle
      saveToLocalStorage()
      return
    }

    // ÊÉÖÂÜµ2ÔºöÂΩìÂâçÊ†áÈ¢ò‰∏éÊèêÂèñÁöÑÊ†áÈ¢ò‰∏çÂêåÔºå‰∏îÊèêÂèñÁöÑÊòØmarkdownÊ†áÈ¢òÔºåÂàôÊõ¥Êñ∞
    const headingMatch = content.match(/^#+\s*(.+)$/m)
    if (headingMatch && doc.title !== extractedTitle) {
      doc.title = extractedTitle
      saveToLocalStorage()
    }
  } else if (!content.trim() && !doc.title.startsWith(t('documents.untitled'))) {
    // ÊÉÖÂÜµ3ÔºöÂÜÖÂÆπ‰∏∫Á©∫‰ΩÜÊ†áÈ¢ò‰∏çÊòØÈªòËÆ§ÁöÑÔºå‰øùÊåÅÂΩìÂâçÊ†áÈ¢ò‰∏çÂèò
    // ËøôÊ†∑Áî®Êà∑ÊâãÂä®ËÆæÁΩÆÁöÑÊ†áÈ¢òÂú®Ê∏ÖÁ©∫ÂÜÖÂÆπÊó∂‰∏ç‰ºö‰∏¢Â§±
  }
}

// Êõ¥Êñ∞ÊªöÂä®Êù°
function updateScrollbar() {
  if (!tabsScrollRef.value) return

  const scrollEl = tabsScrollRef.value
  const scrollWidth = scrollEl.scrollWidth
  const clientWidth = scrollEl.clientWidth

  // Âà§Êñ≠ÊòØÂê¶ÈúÄË¶ÅÊòæÁ§∫ÊªöÂä®Êù°
  showScrollbar.value = scrollWidth > clientWidth

  if (showScrollbar.value) {
    // ËÆ°ÁÆóÊªöÂä®Êù°thumbÁöÑÂÆΩÂ∫¶ÔºàÁôæÂàÜÊØîÔºâ
    scrollbarThumbWidth.value = (clientWidth / scrollWidth) * 100

    // ËÆ°ÁÆóÊªöÂä®Êù°thumbÁöÑ‰ΩçÁΩÆ
    const scrollPercentage = scrollEl.scrollLeft / (scrollWidth - clientWidth)
    const maxThumbPosition = clientWidth - (clientWidth * scrollbarThumbWidth.value / 100)
    scrollbarThumbPosition.value = scrollPercentage * maxThumbPosition
  }
}

// ÁªëÂÆöÊªöÂä®Êù°‰∫ã‰ª∂
function bindScrollbarEvents() {
  if (!tabsScrollRef.value) return

  const scrollEl = tabsScrollRef.value

  // ÁõëÂê¨ÊªöÂä®‰∫ã‰ª∂
  const handleScroll = () => {
    updateScrollbar()
  }

  // ÁõëÂê¨Â∞∫ÂØ∏ÂèòÂåñ
  const resizeObserver = new ResizeObserver(() => {
    updateScrollbar()
  })

  scrollEl.addEventListener('scroll', handleScroll)
  resizeObserver.observe(scrollEl)

  // Ê∏ÖÁêÜÂáΩÊï∞
  const cleanup = () => {
    scrollEl.removeEventListener('scroll', handleScroll)
    resizeObserver.disconnect()
  }

  scrollCleanups.push(cleanup)
}

// Ëé∑ÂèñHTMLÂÜÖÂÆπ
function getHTML() {
  if (vd && isVditorReady) {
    return vd.getHTML()
  }
  return ''
}

onMounted(() => {
  initializeDocuments()
  nextTick(() => {
    initVditor()
    // ÂàùÂßãÂåñÊªöÂä®Êù°
    setTimeout(() => {
      bindScrollbarEvents()
      updateScrollbar()
    }, 100)
  })
})

onBeforeUnmount(() => {
  // ‰øùÂ≠òÂΩìÂâçÁä∂ÊÄÅ
  saveCurrentDocumentState()
  saveToLocalStorage()
  if (imageCleanupTimer) {
    clearTimeout(imageCleanupTimer)
    imageCleanupTimer = null
  }
  destroyVditor()
})

// Êö¥Èú≤ÊñπÊ≥ïÁªôÁà∂ÁªÑ‰ª∂
defineExpose({
  getHTML,
  createNewDocument,
  openDocument,
  closeTab,
  duplicateDocument
})
</script>

<style lang="less" scoped>
@import '../styles/less/variables/colors.less';
@import '../styles/less/variables/layout.less';
@import '../styles/less/variables/typography.less';
@import '../styles/less/mixins/common.less';
// Import the UniEditor component styles
@import '../styles/less/components/uni-editor.less';
</style>
